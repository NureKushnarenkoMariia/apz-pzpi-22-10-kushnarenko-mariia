Міністерство освіти і науки України
 
Харківський національний
університет радіоелектроніки
 


Кафедра «Програмна інженерія»
 
 


ЗВІТ
до практичного заняття №1 з дисципліни
«Архітектура програмного забезпечення»
На тему: «Патерн проєктування Strategy»
 



Виконала:                                                           	          Прийняв:
ст. гр. ПЗПІ-22-10                                    	       		ст. викладач кафедри ПІ
Кушнаренко М. О. 						Сокорчук І. П.




Харків 2025

1 ІСТОРІЯ ЗМІН

Таблиця 1 – Історія змін 
№
Дата
  Версія звіту
Опис змін та виправлень
1
10.04.2025
    1.0.1
Створення слайдів презентації
2
13.04.2025
    1.0.2
Створення текстового звіту, додавання розділів «Завдання», «Опис виконаної роботи», «Висновки», додавання додатків Б та В
3
14.04.2025
    1.0.4
Створення відеозапису доповіді та створення додатку А



2 ЗАВДАННЯ
     Підготувати доповідь на тему: «Патерн проєктування Strategy». Створити та оформити слайди презентації доповіді. Створити та опублікувати на YouTube відеозапис доповіді.
     
3 ОПИС ВИКОНАНОЇ РОБОТИ
     У рамках практичної роботи було досліджено патерн проєктування Strategy, який належить до поведінкових шаблонів проєктування. Спочатку було вивчено теоретичні аспекти патерну: його структуру, принцип роботи, переваги та недоліки. Для наочного пояснення було створено презентацію, що включає UML-діаграму, опис елементів патерну, приклади використання в реальних системах, та фрагменти коду.
     У кінці було створено відеозапис доповіді з поясненням теми та демонстрацією реалізації, який опубліковано на YouTube.

4 ВИСНОВКИ
     У ході виконання практичної роботи було досліджено патерн проєктування Strategy, створено презентацію з теоретичним та практичним матеріалом, а також реалізовано приклад застосування патерну мовою C#. Було розроблено UML-діаграму, написано відповідний код, що демонструє можливість динамічної зміни алгоритму сортування. Результати роботи опубліковано у формі відеодоповіді на платформі YouTube. Отже, Strategy – це поведінковий патерн проєктування, який дозволяє визначати сімейство алгоритмів, інкапсулювати кожен з них і робити їх взаємозамінними. Патерн дозволяє змінювати алгоритм незалежно від клієнта, що ним користується. Це особливо зручно у випадках, коли програма має використовувати різні варіанти поведінки залежно від ситуації, і ці варіанти потрібно легко замінювати або розширювати.
ДОДАТОК А
Посилання на відеозапис доповіді та текст хронологічного опису доповіді
     
     Посилання на відеозапис доповіді на ресурсі YouTube: https://youtu.be/EifIjphNzpY
     
     Текст хронологічного опису доповіді (таймкоди):
     00:00 - Початок
     00:08 - Визначення патерну Strategy
     01:02 - Cтруктура патерну Strategy
     02:25 - UML діаграма реалізації патерну
     03:17 - Опис принципу роботи патерну
     04:07 - Опис переваг даного патерну
     05:10 - Опис недоліків патерну
     06:13 - Чому цей патерн є корисним
     06:57 - Опис роботи програмного коду для демонстрації роботи патерну
     07:40 - Список покращень у коді завдяки патерну
     08:00 - Реалізація патерну Strategy у програмному коді
     08:26 - Висновки
     09:17 - Список літератури
     


ДОДАТОК Б
Слайди презентації доповіді


Рисунок Б.1 – Титульний аркуш


Рисунок Б.2 – Визначення патерну Strategy

Рисунок Б.3 – Cтруктура патерну Strategy


Рисунок Б.4 – UML діаграма реалізації патерну


Рисунок Б.5 – Опис принципу роботи патерну


Рисунок Б.6 – Опис переваг даного патерну
    
Рисунок Б.7 – Опис недоліків патерну


Рисунок Б.8 – Чому цей патерн є корисним


Рисунок Б.9 – Опис роботи програмного коду для демонстрації роботи патерну


Рисунок Б.10 – Список покращень у коді завдяки патерну


Рисунок Б.11 – Реалізація патерну Strategy у програмному коді


Рисунок Б.12 – Реалізація патерну Strategy у програмному коді (продовження)


Рисунок Б.13 – Висновки по виконаній роботі


Рисунок Б.14 – Список використаної літератури


ДОДАТОК В
Приклади програмного коду
     
      1  using System;
      2  using System.Collections.Generic;
      3  using System.Linq;
      4  using System.Text;
      5  using System.Threading.Tasks;
      6 
      7 
      8  // Стратегія: Інтерфейс для алгоритму сортування
      9  public interface ISortingStrategy
      10  {
      11      void Sort(int[] array);
      12  }
      13  
      14  // Конкретна стратегія: Сортування бульбашкою
      15  public class BubbleSort : ISortingStrategy
      16  {
      17      public void Sort(int[] array)
      18      {
      19          Console.WriteLine("Використано сортування бульбашкою");
      20          int temp;
      21          for (int i = 0; i < array.Length - 1; i++)
      22          {
      23              for (int j = 0; j < array.Length - 1 - i; j++)
      24              {
      25                   if (array[j] > array[j + 1])
      26                 {
      27                      temp = array[j];
      28                      array[j] = array[j + 1];
      29                      array[j + 1] = temp;
      30                  }
      31              }
      32          }
      33      }
      34  }
      35  
      36   // Конкретна стратегія: Швидке сортування
      37  public class QuickSort : ISortingStrategy
      38  {
      39      public void Sort(int[] array)
      40      {
      41          Console.WriteLine("Використано швидке сортування");
      42          QuickSortAlgorithm(array, 0, array.Length - 1);
      43      }
      44 
      45      private void QuickSortAlgorithm(int[] array, int low, int high)
      46      {
      47          if (low < high)
      48          {
      49              int pivotIndex = Partition(array, low, high);
      50              QuickSortAlgorithm(array, low, pivotIndex - 1);
      51              QuickSortAlgorithm(array, pivotIndex + 1, high);
      52          }
      53      }
      54  
      55      private int Partition(int[] array, int low, int high)
      56      {
      57          int pivot = array[high];
      58          int i = low - 1;
      59          for (int j = low; j <= high - 1; j++)
      60          {
      61               if (array[j] < pivot)
      62             {
      63                  i++;
      64                  Swap(ref array[i], ref array[j]);
      65              }
      66          }
      67          Swap(ref array[i + 1], ref array[high]);
      68          return i + 1;
      69      }
      70  
      71      private void Swap(ref int a, ref int b)
      72      {
      73          int temp = a;
      74          a = b;
      75          b = temp;
      76      }
      77  }
      78  
      79  // Клас контексту, який використовує стратегію
      80  public class Sorter
      81  {
      82      private ISortingStrategy _sortingStrategy;
      83  
      84      public Sorter(ISortingStrategy sortingStrategy)
      85      {
      86          _sortingStrategy = sortingStrategy;
      87      } 
      88  
      89      public void SetSortingStrategy(ISortingStrategy sortingStrategy)
      90      {
      91          _sortingStrategy = sortingStrategy;
      92      }
      93 
      94      public void SortArray(int[] array)
      95      {
      96          _sortingStrategy.Sort(array);
      97          Console.WriteLine("Результат сортування: " + string.Join(", ", array));
      98      }
      99  }
      100  
      101  class Program
      102  {
      103      static void Main()
      104      {
      105          // Приклад використання стратегії сортування
      106  
      107          int[] array = { 5, 3, 8, 6, 2, 7 };
      108  
      109          // Спочатку використовуємо BubbleSort
      110          Sorter sorter = new Sorter(new BubbleSort());
      111          sorter.SortArray(array);
      112  
      113          // Змінюємо стратегію на QuickSort
      114          Console.WriteLine();
      115          sorter.SetSortingStrategy(new QuickSort());
      116          sorter.SortArray(array);
      117      }
      118  }


